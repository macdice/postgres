--
-- PG_LSN
--
CREATE TABLE PG_LSN_TBL (f1 pg_lsn);
-- Largest and smallest input
INSERT INTO PG_LSN_TBL VALUES ('0/0');
INSERT INTO PG_LSN_TBL VALUES ('FFFFFFFF/FFFFFFFF');
-- Incorrect input
INSERT INTO PG_LSN_TBL VALUES ('G/0');
ERROR:  invalid input syntax for type pg_lsn: "G/0"
LINE 1: INSERT INTO PG_LSN_TBL VALUES ('G/0');
                                       ^
INSERT INTO PG_LSN_TBL VALUES ('-1/0');
ERROR:  invalid input syntax for type pg_lsn: "-1/0"
LINE 1: INSERT INTO PG_LSN_TBL VALUES ('-1/0');
                                       ^
INSERT INTO PG_LSN_TBL VALUES (' 0/12345678');
ERROR:  invalid input syntax for type pg_lsn: " 0/12345678"
LINE 1: INSERT INTO PG_LSN_TBL VALUES (' 0/12345678');
                                       ^
INSERT INTO PG_LSN_TBL VALUES ('ABCD/');
ERROR:  invalid input syntax for type pg_lsn: "ABCD/"
LINE 1: INSERT INTO PG_LSN_TBL VALUES ('ABCD/');
                                       ^
INSERT INTO PG_LSN_TBL VALUES ('/ABCD');
ERROR:  invalid input syntax for type pg_lsn: "/ABCD"
LINE 1: INSERT INTO PG_LSN_TBL VALUES ('/ABCD');
                                       ^
-- Also try it with non-error-throwing API
SELECT pg_input_is_valid('G', 'pg_lsn');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('ZZZ', 'pg_lsn');
                   message                   | detail | hint | sql_error_code 
---------------------------------------------+--------+------+----------------
 invalid input syntax for type pg_lsn: "ZZZ" |        |      | 22P02
(1 row)

-- Min/Max aggregation
SELECT MIN(f1), MAX(f1) FROM PG_LSN_TBL;
       min        |       max        
------------------+------------------
 0000000000000000 | FFFFFFFFFFFFFFFF
(1 row)

DROP TABLE PG_LSN_TBL;
-- Operators
SELECT '0/16AE7F8' = '0/16AE7F8'::pg_lsn;
 ?column? 
----------
 t
(1 row)

SELECT '0/16AE7F8'::pg_lsn != '0/16AE7F7';
 ?column? 
----------
 t
(1 row)

SELECT '0/16AE7F7' < '0/16AE7F8'::pg_lsn;
 ?column? 
----------
 t
(1 row)

SELECT '0/16AE7F8' > pg_lsn '0/16AE7F7';
 ?column? 
----------
 t
(1 row)

SELECT '0/16AE7F7'::pg_lsn - '0/16AE7F8'::pg_lsn;
 ?column? 
----------
       -1
(1 row)

SELECT '0/16AE7F8'::pg_lsn - '0/16AE7F7'::pg_lsn;
 ?column? 
----------
        1
(1 row)

SELECT '0/16AE7F7'::pg_lsn + 16::numeric;
     ?column?     
------------------
 00000000016AE807
(1 row)

SELECT 16::numeric + '0/16AE7F7'::pg_lsn;
     ?column?     
------------------
 00000000016AE807
(1 row)

SELECT '0/16AE7F7'::pg_lsn - 16::numeric;
     ?column?     
------------------
 00000000016AE7E7
(1 row)

SELECT 'FFFFFFFF/FFFFFFFE'::pg_lsn + 1::numeric;
     ?column?     
------------------
 FFFFFFFFFFFFFFFF
(1 row)

SELECT 'FFFFFFFF/FFFFFFFE'::pg_lsn + 2::numeric; -- out of range error
ERROR:  pg_lsn out of range
SELECT '0/1'::pg_lsn - 1::numeric;
     ?column?     
------------------
 0000000000000000
(1 row)

SELECT '0/1'::pg_lsn - 2::numeric; -- out of range error
ERROR:  pg_lsn out of range
SELECT '0/0'::pg_lsn + ('FFFFFFFF/FFFFFFFF'::pg_lsn - '0/0'::pg_lsn);
     ?column?     
------------------
 FFFFFFFFFFFFFFFF
(1 row)

SELECT 'FFFFFFFF/FFFFFFFF'::pg_lsn - ('FFFFFFFF/FFFFFFFF'::pg_lsn - '0/0'::pg_lsn);
     ?column?     
------------------
 0000000000000000
(1 row)

SELECT '0/16AE7F7'::pg_lsn + 'NaN'::numeric;
ERROR:  cannot add NaN to pg_lsn
SELECT '0/16AE7F7'::pg_lsn - 'NaN'::numeric;
ERROR:  cannot subtract NaN from pg_lsn
-- Check btree and hash opclasses
EXPLAIN (COSTS OFF)
SELECT DISTINCT (i || '/' || j)::pg_lsn f
  FROM generate_series(1, 10) i,
       generate_series(1, 10) j,
       generate_series(1, 5) k
  WHERE i <= 10 AND j > 0 AND j <= 10
  ORDER BY f;
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Sort
   Sort Key: (((((i.i)::text || '/'::text) || (j.j)::text))::pg_lsn)
   ->  HashAggregate
         Group Key: ((((i.i)::text || '/'::text) || (j.j)::text))::pg_lsn
         ->  Nested Loop
               ->  Function Scan on generate_series k
               ->  Materialize
                     ->  Nested Loop
                           ->  Function Scan on generate_series j
                                 Filter: ((j > 0) AND (j <= 10))
                           ->  Function Scan on generate_series i
                                 Filter: (i <= 10)
(12 rows)

SELECT DISTINCT (i || '/' || j)::pg_lsn f
  FROM generate_series(1, 10) i,
       generate_series(1, 10) j,
       generate_series(1, 5) k
  WHERE i <= 10 AND j > 0 AND j <= 10
  ORDER BY f;
        f         
------------------
 0000000100000001
 0000000100000002
 0000000100000003
 0000000100000004
 0000000100000005
 0000000100000006
 0000000100000007
 0000000100000008
 0000000100000009
 0000000100000010
 0000000200000001
 0000000200000002
 0000000200000003
 0000000200000004
 0000000200000005
 0000000200000006
 0000000200000007
 0000000200000008
 0000000200000009
 0000000200000010
 0000000300000001
 0000000300000002
 0000000300000003
 0000000300000004
 0000000300000005
 0000000300000006
 0000000300000007
 0000000300000008
 0000000300000009
 0000000300000010
 0000000400000001
 0000000400000002
 0000000400000003
 0000000400000004
 0000000400000005
 0000000400000006
 0000000400000007
 0000000400000008
 0000000400000009
 0000000400000010
 0000000500000001
 0000000500000002
 0000000500000003
 0000000500000004
 0000000500000005
 0000000500000006
 0000000500000007
 0000000500000008
 0000000500000009
 0000000500000010
 0000000600000001
 0000000600000002
 0000000600000003
 0000000600000004
 0000000600000005
 0000000600000006
 0000000600000007
 0000000600000008
 0000000600000009
 0000000600000010
 0000000700000001
 0000000700000002
 0000000700000003
 0000000700000004
 0000000700000005
 0000000700000006
 0000000700000007
 0000000700000008
 0000000700000009
 0000000700000010
 0000000800000001
 0000000800000002
 0000000800000003
 0000000800000004
 0000000800000005
 0000000800000006
 0000000800000007
 0000000800000008
 0000000800000009
 0000000800000010
 0000000900000001
 0000000900000002
 0000000900000003
 0000000900000004
 0000000900000005
 0000000900000006
 0000000900000007
 0000000900000008
 0000000900000009
 0000000900000010
 0000001000000001
 0000001000000002
 0000001000000003
 0000001000000004
 0000001000000005
 0000001000000006
 0000001000000007
 0000001000000008
 0000001000000009
 0000001000000010
(100 rows)

